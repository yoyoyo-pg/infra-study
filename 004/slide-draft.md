# はじめに

- 有志勉強会第四弾です
- 今回は「マイクロサービスパターン[実践的システムデザインのためのコード解説] 」といった書籍を基にしたマイクロサービスについての解説です。

## 第一章

### FTGOアプリの事例紹介

#### アプリケーションの特徴

- 一つのWARから構成
- ヘキサゴナルアーキテクチャ(<https://qiita.com/cocoa-maemae/items/b08c4cf95d47e314e2dc>)
- GoFのアダプターパターンを採用
- ユーザー側のポートとDB側のポートを用意
- アプリケーションの核の部分がビジネスロジックで、周りを様々なアダプタが取り囲み連携している
- モバイルアプリケーションのUI等もアダプタの一つ
- MySQLへの接続もアダプタの一つで、アプリケーションは論理的にはモジュール化されている
- モノシリックなアーキテクチャが小さかった頃に関しては、大きな変更をしやすい、テストしやすい、デプロイしやすい等のメリットがあった

#### モノリシック地獄の実際

- FTGO開発部、複数のチームが同一のリポジトリを管理
- 大きすぎるために、一人の開発者が完全に理解することが出来ない→バグを修正して新機能を正しく実装するのに時間がかかる
- ビルドに時間がかかる。ちなみにAmazonは2011年の段階で11.6秒に一回、コード変更を本番システムにデプロイしていた
- FTGOは月に複数回更新をかけるのもきつい
- スケーリングが厳しい。アプリケーションに応じてリソースの要件が異なるが、同じWAR。
- 信頼性が低い。サイズが大きすぎるためにアプリケーションの徹底的なテストが難しい。＆障害の分離が出来ない
- 次第に陳腐化していくテクノロジスタックに縛り付けられる。（=最新のフレームワークや言語を採用しづらく）
- GoやnodeJSを入れたいが、それもできない。

### マイクロサービスについて

#### スケールキューブについて

- x,y,zの3軸でのスケーリング方法を定義
  - x軸は、水平スケーリング、z軸はルーティング（ユーザー別に処理インスタンスの変更）
    - アプリケーションの処理能力と可用性を引き上げるが、開発とアプリケーションが複雑化する問題には対応できない
  - y軸は機能に基づいてアプリケーションをサービスに分割
    - 機能に基づいて、更にその中でx軸、y軸のスケーリングが可能

#### マイクロサービスの特徴

- マイクロサービスはモジュール性の一形態
  - サービスがお互いに疎結合で、API以外では通信できない
  - 個々のサービスは専用のDBを持つ
    - オーダーサービスはORDERSテーブルを含む専用DB、顧客サービスはCUSTOMERSテーブルを含む専用DBを持つ
    - 外部アプリはAPI（REST、gRPC）を介してしか該当DBの情報を取得できない
  - 他のサービスと調整しなくとも、サービスのスキーマを変更できる。
    - 各サービスは、DDDのサブドメインに対応している。
  - サービスは独立したリポジトリ、パイプラインを持つ

#### マイクロサービスの利点

- 大規模で複雑なアプリケーションの継続的デリバリ／デプロイを可能にする
  - 個々のサービスが小さく、テストが書きやすく、短時間で実行される
  - 他のサービスから独立して、個別にデプロイできる
  - ビジネス要件として、素早い要望への対応が可能で、信頼性の高いアプリケーションに
- 個々のサービスが小さく、簡単にメンテナンスできる
  - コードを理解しやすく、IDEが遅くなることもない
- サービスをそれぞれ個別にデプロイ、スケーリングできる
  - リソース要件に応じてスケール。（ハード面を考慮し）
- チームに自主性、自立性を与える
  - two piza teamを構成できる。独立して開発できるので、開発速度が早い
- 障害分離に優れている
  - 他のサービスに影響を与えない（一部分のダウンで済む）
- 新しいテクノロジを簡単に実験、採用できる
  - テクノロジスタックに長期に縛られない
  - 最初に選択したテクノロジに縛られる事がない

#### マイクロサービスの欠点

- サービスの適切な分割方法を見つけるのが難しい
  - 分割方法を間違えると、一緒にデプロイする必要のある蜜結合のサービスが生まれてしまう
- 分散システムは複雑になる
  - メソッドの呼び出しよりも複雑なプロセス間通信が必要
  - プロセス間通信の失敗の処理などが必要
  - IDEはモノシリックアプリケーションの開発を対象としている事が多い
  - 高度なソフトウェア開発、デリバリースキルが必要

### ソフトウェア開発と組織

#### コンウェイの法則

- 「システムを設計する組織は、組織のコミュニケーション構造をコピーしたような設計しか作れない」
- 一つの大規模なチームよりも、複数の小さなチームの方が作業速度が速くなる
  - チームとチームが担当するサービスを分割し、コミュニケーションのオーバーヘッドを避ける

#### デリバリープロセス

- マイクロサービスをウォーターフォールで開発すると、開発速度の速さが打ち消されてしまう
  - Scrumやカンバン等アジャイルを取り入れる必要がある
- 継続的デリバリーを取り入れる事も重要で、自動テストや自動デプロイといった自動化が必要

## 第二章

### 3層アーキテクチャの弱点

- プレゼンテーション層、ビジネスロジック層、永続記憶層
  - 単一もプレゼンテーション層の場合、アプリケーションが複数のシステムから呼び出されるかもしれないことを実現できていない
  - 単一の永続記憶層の場合、アプリケーションが複数のＤＢを操作するかもしれないことを実現できていない
  - 永続記憶層に依存するビジネスロジックの場合、ロジック単体のテストが実装出来ない
- ヘキサゴナルアーキテクチャで、アダプタを持つことで、ロジックを分離する

### サービスとは

- 何らかの役に立つ機能を実装するスタンドアロンの個別にデプロイ出来るソフトウェアコンポーネントの事
- 開発者は、APIを迂回してサービス実装に直接アクセスするコードを書くことは出来ない

## マイクロサービスのテスト

### テストのタイプ

- ユニットテスト・・・クラスなど、サービスを構成するソフトウェアコンポーネントをテストする
- インテグレーションテスト・・・サービスがDB等のインフラや他のアプリケーションと連携できることをチェックする
- コンポーネントテスト・・・個々のサービスの受け入れテスト
- エンドツーエンドテスト・・・アプリケーション全体の受け入れテスト

memo
・SOAとの比較、パターンとパターン言語については読み飛ばす
